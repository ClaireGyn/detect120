from __future__ import print_function
##CUSP UO 2016
__author__ = "fbb"

import glob
import numpy as np
import optparse
import pylab as pl
import sys
import os
import pickle as pkl
import json
import scipy.optimize
import datetime

from images2gif import writeGif
from PIL import Image, ImageSequence
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
import IPython.display as IPdisplay

from scipy.stats import mode
from findImageSize import findsize
s = json.load( open("fbb_matplotlibrc.json") )
pl.rcParams.update(s)


font = {'size'   : 13}

kelly_colors_hex = [
    '#FFB300', # Vivid Yellow
    '#803E75', # Strong Purple
    '#FF6800', # Vivid Orange
    '#A6BDD7', # Very Light Blue
    '#C10020', # Vivid Red
    '#CEA262', # Grayish Yellow
    '#817066', # Medium Gray
    '#007D34', # Vivid Green
    '#F6768E', # Strong Purplish Pink
    '#00538A', # Strong Blue
    '#FF7A5C', # Strong Yellowish Pink
    '#53377A', # Strong Violet
    '#FF8E00', # Vivid Orange Yellow
    '#B32851', # Strong Purplish Red
    '#F4C800', # Vivid Greenish Yellow
    '#7F180D', # Strong Reddish Brown
    '#93AA00', # Vivid Yellowish Green
    '#593315', # Deep Yellowish Brown
    '#F13A13', # Vivid Reddish Orange
    '#232C16', # Dark Olive Green
    ]


import pandas as pd

if __name__ == '__main__':
    
    parser = optparse.OptionParser(usage="makemoneyplot.py 'filepattern' ",   
                                       conflict_handler="resolve")
    parser.add_option('--nmax', default=100, type="int",
                      help='number of images to process (i.e. timestamps)')
    parser.add_option('--lmax', default=None, type="int",
                      help='number of lights')
    
    parser.add_option('--skipfiles', default=150, type="int",
                      help="number of files to skip at the beginning")      
    parser.add_option('--coordfile', default=None, type="str",
                      help='coordinates python array (generated by windowFinder.py)')
    parser.add_option('--fft', default=False, action="store_true",
                      help='custer in fourier space')
    parser.add_option('--ref', default=None, type="str",
                      help='reference star (format: x,y)')
    parser.add_option('--offset', default=False, action="store_true",
                      help='plot offset thather than phase')

    
    options,  args = parser.parse_args()
    if len(args) < 1:
        sys.argv.append('--help')
        options,  args = parser.parse_args()
           
        sys.exit(0)
    xmax = 0
    phaseflist = []
    ref = [np.nan,np.nan]
    if options.ref:
        ref = (int(float(options.ref.split(',')[0])), int(float(options.ref.split(',')[1])))   #if 2117.12,502.52
        if options.coordfile:
            stack = np.load(options.coordfile.replace("_coords.npy",".npy"))
            imsize  = findsize(stack,
                           filepattern=options.coordfile.replace('.npy','.txt'))
            fig = pl.figure(figsize=(20,10))
            axstack = fig.add_subplot(224)
            axstack.imshow(stack,  interpolation='nearest')
            axstack.set_xlim(0, axstack.get_xlim()[1])
            axstack.set_ylim(axstack.get_ylim()[0], 0)
            axstack.axis('off')
            circle1 = pl.Circle(ref, 30, color='r', fill=False, lw=2)
            axstack.add_artist(circle1)
            
            #stackfig.savefig("moneyplot_stack.pdf")
            
    for arg in args:
        filepattern = arg
        impath = os.getenv("UIdata") + filepattern
        print ("\n\nUsing image path: %s\n\n"%impath)

        fnameroot = filepattern.split('/')[-1]


        flist = sorted(glob.glob(impath+"*.raw"))

        print ("Total number of image files: %d"%len(flist))

        nmax = min(options.nmax, len(flist)-options.skipfiles)
        print ("Number of timestamps (files): %d"%(nmax))
        if nmax<30: continue
        lmax = options.lmax
        if not lmax:
            if options.coordfile:
                print ("Using coordinates file", options.coordfile)
                try:
                    allights = np.load(options.coordfile)
                except:
                    print ("you need to create the window mask, you can use windowFinder.py")
                    sys.exit()
            elif os.path.isfile(filepattern+"_allights.npy") :
                try:
                    allights = np.load(filepattern+"_allights.npy")
                except:
                    print ("you need to create the window mask, you can use windowFinder.py")
                    print (filepattern+"_allights.npy")
                    sys.exit()

            else:
                print ("you need to create the window mask, or pass the number of windows lmax")
                sys.exit()
        
        
            lmax = len(allights)
            if options.lmax: lmax = min([lmax, options.lmax])

    
        if options.fft:
            phasefilename = filepattern+\
                            "_fft_phases_N%04dW%04dS%04d.dat"%(nmax,
                                                               lmax,
                                                               options.skipfiles)
        else:
            phasefilename = filepattern+\
                            "_phases_N%04dW%04dS%04d.dat"%(nmax,
                                                                       lmax,
                                                                       options.skipfiles)
        phaseflist.append(phasefilename)
    phaseflist = np.array(phaseflist)
    fft = ['','fft']
    indx = np.array(['fft' in fl for fl in phaseflist])
    print (indx)
    #(glob.glob("ESB*[0-9]_phases_N2009.dat"))
    flist1 = phaseflist[~indx]
    flist2 = phaseflist[indx]
    print (['%s'%tm for tm in np.arange(len(flist1))*15])
    
    for fi,fl in enumerate([flist1]):#,flist2]):
        refphase = np.zeros(len(flist1))
        ax = fig.add_subplot(2,2,fi+1)
        axref = fig.add_subplot(2,2,fi+3)
        phases = []
        for f in fl:
            print (f)
            try: phases.append(pd.read_csv(f))
            except ValueError: pass
            #print (phases)

        allcoords = []
        #np.concatenate([(p['x'].values,p['y'].values) for p in phases])

        for p in phases:
            for dp in np.arange(len(p['y'].values)):
                if not ( p['x'].values[dp], p['y'].values[dp]) in allcoords:
                    allcoords.append(( p['x'].values[dp], p['y'].values[dp]))
                    #print (allcoords)
        alllights = {}
        
        for i,xy in enumerate(allcoords):
            alllights[i] = {}
            alllights[i]['xy'] = (int(xy[0]),int(xy[1]))
            alllights[i]['phases'] = np.zeros(len(phases))*np.nan
            alllights[i]['loc'] = np.zeros(len(phases))*np.nan
            for j,p in enumerate(phases):
                if len(p)>0:
                    #print (alllights[i]['xy'][0], alllights[i]['xy'][1])
                    #print (p[(p.x.values.astype('int')==alllights[i]['xy'][0] )*(p.y.values.astype('int')==alllights[i]['xy'][1])])
                    #['xy'][0].phase
                    tmpind = (p.x.values.astype('int')==alllights[i]['xy'][0] )*(p.y.values.astype('int')==alllights[i]['xy'][1])
                    ph = p[tmpind].phase.values
                    if len(ph)>0:
                        alllights[i]['phases'][j]=ph
                    r = alllights[i]['xy'][0]**2+alllights[i]['xy'][1]**2
                    if len(ph)>0 and not np.isnan(r):
                        alllights[i]['loc']=np.sqrt(r)
        allds = np.array([alllights[i]['loc'] for i in alllights])
        allds = (allds -  allds.min())
        allds = allds/allds.max()
        print (allds, allds.min(), allds.max())
        for i in alllights:
            if not np.isnan(ref[0]) and alllights[i]['xy']==ref:
                refphases = alllights[i]['phases']
        print ("Ref phases",refphases)
        #print (alllights)
        #indlist = np.arange(len(alllights)*1.0)/len(alllights)
        #np.random.shuffle(indlist)
        #maxdistance = np.nanmax([alllights[i]['loc'] for i in alllights])
        #alllights[i]['loc']/alllights[i]['loc'].max()
        #print (indlist, ph)
        #print (indlist)
        mycm = pl.cm.gist_rainbow(allds)
        #print( mycm)

        phasediff = np.zeros((len(phases),len(alllights)))

        mymode = np.zeros(len(phases))
        myref = np.zeros(len(phases))
        if options.offset:

            for i in np.arange(len(phases)):
                
                for l in alllights:
                    phasediff[i][l]  = alllights[l]['phases'][0]-alllights[l]['phases'][i]
                    #ax.plot(i, phasediff[l], 'o', color = mycm[l])

            
                    mymode[i] = np.nanmedian(phasediff[i])
                
                if not np.isnan(ref[0]):
                    myref[i] = refphases[0]-refphases[i]
                ax.scatter([i]*len(phasediff[i]), phasediff[i]-mymode[i], 
                            color = mycm, alpha=0.5)                
                for l in alllights:
                    #phasediff[l]  = alllights[l]['phases'][0]-alllights[l]['phases'][i]
                    if i>0:
                        if np.abs(phasediff[i-1][l]-mymode[i-1] - phasediff[i][l]+mymode[i])<0.1:
                            #print (i, phasediff_old)
                            ax.plot([i-1,i], [phasediff[i-1][l]-mymode[i-1], phasediff[i][l]-mymode[i]], 'k-', alpha=0.5, lw=0.3)
                        else:
                            ax.plot([i-1,i], [phasediff[i-1][l]-mymode[i-1], phasediff[i][l]-mymode[i]], '-', color = 'IndianRed', alpha=0.5)
                            #phasediff_old[l] = phasediff[l]

                        axref.plot(i, phasediff[i][l]-myref[i], 'o', color = mycm[l],alpha=0.5)
                    if i>0:
                        if np.abs(phasediff[i-1][l]-myref[i-1] - phasediff[i][l]+myref[i])<0.1:
                            #print (i, phasediff_old)
                            axref.plot([i-1,i], [phasediff[i-1][l]-myref[i-1], phasediff[i][l]-myref[i]], 'k-', alpha=0.5, lw=0.3)
                        else:
                            axref.plot([i-1,i], [phasediff[i-1][l]-myref[i-1], phasediff[i][l]-myref[i]], '-', color = 'IndianRed', alpha=0.5)
                            #phasediff_old[l] = phasediff[l]


        else:
            mymode = np.zeros(len(phases))
            myref = np.zeros(len(phases))
            for i in np.arange(len(phases)):
                
                for l in alllights:
                    phasediff[i][l]  = alllights[l]['phases'][i]
                    #ax.plot(i, phasediff[l], 'o', color = mycm[l])

            
                    mymode[i] = np.nanmedian(phasediff[i])
                
                if not np.isnan(ref[0]):
                    myref[i] = refphases[0]-refphases[i]
                
                
                for l in alllights:
                    #phasediff[l]  = alllights[l]['phases'][0]-alllights[l]['phases'][i]
                    ax.scatter(i, phasediff[i][l]-mymode[i], 
                            color = mycm[l], alpha=0.5)
                    
                    if i>0:
                        if np.abs(phasediff[i-1][l]-mymode[i-1] -\
                                  phasediff[i][l]+mymode[i])<0.1:
                            #print (i, phasediff_old)
                            ax.plot([i-1,i], [phasediff[i-1][l]-mymode[i-1],
                                              phasediff[i][l]-mymode[i]],
                                    'k-', alpha=0.5, lw=0.3)
                        else:
                            ax.plot([i-1,i], [phasediff[i-1][l]-mymode[i-1],
                                              phasediff[i][l]-mymode[i]],
                                    '-', color = 'IndianRed', alpha=0.5)
                            #phasediff_old[l] = phasediff[l]

                        
                    if i>0:
                        if np.abs(phasediff[i-1][l]-myref[i-1] - \
                                  phasediff[i][l]+myref[i])<0.1:
                            #print (i, phasediff_old)
                            axref.plot([i-1,i], [phasediff[i-1][l]-myref[i-1],
                                                 phasediff[i][l]-myref[i]],
                                       'k-', alpha=0.5, lw=0.3)
                        else:
                            axref.plot([i-1,i], [phasediff[i-1][l]-myref[i-1],
                                                 phasediff[i][l]-myref[i]],
                                       '-', color = 'IndianRed', alpha=0.5)
                            #phasediff_old[l] = phasediff[l]
                            

        right = .85
        top = .85
  
        xmax = max(xmax, ax.get_xlim()[1]*1.1)
        ax.text(right, top, "using median",
        horizontalalignment='right',
        verticalalignment='top',
        transform=ax.transAxes)

        ax.set_xlim(-0.1,xmax)
        ax.set_xlabel("time (minutes from first run)", fontsize=13)
        ax.set_ylabel("phase difference %s (radians)"%(fft[fi]), fontsize=13)
        
        pl.xticks(range(len(flist1)-1),['%s'%tm for tm in np.arange(len(flist1)-1)*15])
        axref.text(right, top, "using reference",
        horizontalalignment='right',
        verticalalignment='top',
        transform=axref.transAxes)
        axref.set_xlim(-0.1,xmax)
        axref.set_xlabel("time (minutes from first run)", fontsize=13)
        axref.set_ylabel("phase difference %s (radians)"%(fft[fi]), fontsize=13)
        
        pl.xticks(range(len(flist1)-1),['%s'%tm for tm in np.arange(len(flist1)-1)*15])
        
    #pl.show()
    if options.offset:
        pl.savefig("moneyplot_offset_%d_%d.pdf"%(ref[0],ref[1]))
    else:
        pl.savefig("moneyplot_phases_%d_%d.pdf"%(ref[0],ref[1]))
    pl.show()

    
